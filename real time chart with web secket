import React, { useEffect, useRef, useState } from "react";

// RealtimeChatWithWebSocket.jsx // Single-file React component implementing a real-time chat UI with WebSocket integration. // All styling is inline (no external CSS). // Replace WS_URL with your WebSocket server URL (e.g. wss://your-server.example/ws)

const WS_URL = "wss://example.com/socket"; // <-- change this

export default function RealtimeChat({ userId = "You", wsUrl = WS_URL }) { const [ws, setWs] = useState(null); const [connected, setConnected] = useState(false); const [messages, setMessages] = useState([]); const [input, setInput] = useState(""); const [typingUsers, setTypingUsers] = useState({}); const [statusMessage, setStatusMessage] = useState(""); const messagesEndRef = useRef(null); const reconnectRef = useRef({ attempts: 0, timer: null }); const wsRef = useRef(null);

useEffect(() => { connect(); return () => { cleanupWebSocket(); }; // eslint-disable-next-line react-hooks/exhaustive-deps }, []);

function cleanupWebSocket() { if (wsRef.current) { wsRef.current.onopen = null; wsRef.current.onclose = null; wsRef.current.onmessage = null; try { wsRef.current.close(); } catch (e) {} wsRef.current = null; } if (reconnectRef.current.timer) { clearTimeout(reconnectRef.current.timer); reconnectRef.current.timer = null; } }

function connect() { cleanupWebSocket(); setStatusMessage("Connecting...");

try {
  const socket = new WebSocket(wsUrl);
  wsRef.current = socket;

  socket.onopen = () => {
    reconnectRef.current.attempts = 0;
    setConnected(true);
    setStatusMessage("Connected");
    // Announce presence
    sendRaw({ type: "presence", user: userId, action: "join", ts: Date.now() });
  };

  socket.onclose = (ev) => {
    setConnected(false);
    setStatusMessage("Disconnected");
    // Try to reconnect with exponential backoff
    const attempts = ++reconnectRef.current.attempts;
    const delay = Math.min(30000, 500 * Math.pow(2, attempts));
    reconnectRef.current.timer = setTimeout(connect, delay);
  };

  socket.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      handleServerMessage(data);
    } catch (err) {
      // if message isn't JSON, just append as raw text
      pushMessage({ id: Date.now() + "-raw", user: "server", text: event.data, ts: Date.now(), raw: true });
    }
  };

  setWs(socket);
} catch (err) {
  setStatusMessage("Failed to create WebSocket");
  // try reconnect later
  reconnectRef.current.timer = setTimeout(connect, 2000);
}

}

function sendRaw(obj) { const socket = wsRef.current; if (!socket || socket.readyState !== WebSocket.OPEN) return false; socket.send(JSON.stringify(obj)); return true; }

function handleServerMessage(data) { // Expected server messages (example formats): // { type: 'message', id, user, text, ts } // { type: 'typing', user, isTyping } // { type: 'presence', user, action }

switch (data.type) {
  case "message":
    pushMessage(data);
    break;
  case "typing":
    setTypingUsers((prev) => ({ ...prev, [data.user]: data.isTyping ? Date.now() : undefined }));
    break;
  case "presence":
    pushMessage({ id: `presence-${data.user}-${Date.now()}`, user: "system", text: `${data.user} ${data.action}` , ts: Date.now(), system: true });
    break;
  default:
    // unknown message types appended
    pushMessage({ id: `unknown-${Date.now()}`, user: "server", text: JSON.stringify(data), ts: Date.now(), raw: true });
}

}

function pushMessage(msg) { setMessages((prev) => { const exists = prev.find((m) => m.id === msg.id); if (exists) return prev; const next = [...prev, msg].sort((a, b) => (a.ts || 0) - (b.ts || 0)); return next; }); // Scroll to bottom deferred setTimeout(() => scrollToBottom(), 50); }

function scrollToBottom() { if (messagesEndRef.current) messagesEndRef.current.scrollIntoView({ behavior: "smooth" }); }

function sendMessage() { if (!input.trim()) return; const payload = { type: "message", id: ${userId}-${Date.now()}, user: userId, text: input, ts: Date.now(), }; // Optimistic UI pushMessage(payload); const ok = sendRaw(payload); if (!ok) { // if not sent, mark system notice pushMessage({ id: sys-${Date.now()}, user: "system", text: "Message queued (disconnected)", ts: Date.now(), system: true }); } setInput(""); // notify stop typing sendRaw({ type: "typing", user: userId, isTyping: false }); }

// typing notifications useEffect(() => { const timeout = setTimeout(() => { if (!input) return; sendRaw({ type: "typing", user: userId, isTyping: true }); }, 250); return () => clearTimeout(timeout); // eslint-disable-next-line react-hooks/exhaustive-deps }, [input]);

function handleInputKey(e) { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); } }

// Derived list of typing users (excluding current user) const otherTyping = Object.entries(typingUsers) .filter(([u, ts]) => u !== userId && ts && Date.now() - ts < 4000) .map(([u]) => u);

// Inline styles (JS objects) const styles = { container: { width: "100%", maxWidth: 900, height: 600, margin: "20px auto", border: "1px solid #ddd", borderRadius: 8, display: "flex", flexDirection: "column", overflow: "hidden", fontFamily: "Inter, Roboto, Arial, sans-serif", boxShadow: "0 6px 18px rgba(0,0,0,0.06)", }, header: { padding: "12px 16px", borderBottom: "1px solid #eee", display: "flex", alignItems: "center", justifyContent: "space-between", background: "linear-gradient(90deg,#fafafa,#ffffff)", }, title: { fontSize: 16, fontWeight: 600, color: "#111" }, status: { fontSize: 12, color: connected ? "#0a0" : "#b00" }, messagesWrap: { flex: 1, padding: 12, overflowY: "auto", background: "#f7f8fa" }, messageRow: { display: "flex", marginBottom: 10 }, bubble: { padding: "10px 12px", borderRadius: 14, maxWidth: "70%", lineHeight: 1.3 }, mine: { marginLeft: "auto", background: "#4b9cff", color: "white", borderBottomRightRadius: 4 }, theirs: { marginRight: "auto", background: "white", color: "#111", borderBottomLeftRadius: 4 }, system: { margin: "6px auto", background: "transparent", color: "#666", fontSize: 13 }, footer: { padding: 12, borderTop: "1px solid #eee", background: "#fff" }, inputArea: { display: "flex", gap: 8, alignItems: "center" }, textarea: { flex: 1, minHeight: 42, maxHeight: 120, resize: "none", padding: 10, borderRadius: 8, border: "1px solid #ddd", fontSize: 14 }, sendBtn: { padding: "8px 12px", borderRadius: 8, border: "none", background: "#1d6ef3", color: "white", cursor: "pointer" }, small: { fontSize: 12, color: "#666" }, };

return ( <div style={styles.container}> <div style={styles.header}> <div style={{ display: "flex", alignItems: "center", gap: 12 }}> <div style={styles.title}>Realtime Chat</div> <div style={styles.small}>as: <strong>{userId}</strong></div> </div> <div style={{ textAlign: "right" }}> <div style={styles.status}>{connected ? "Online" : "Offline"}</div> <div style={styles.small}>{statusMessage}</div> </div> </div>

<div style={styles.messagesWrap}>
    {messages.map((m) => {
      if (m.system) {
        return (
          <div key={m.id} style={styles.system}>{m.text}</div>
        );
      }

      const mine = m.user === userId;
      const rowStyle = { ...styles.messageRow, justifyContent: mine ? "flex-end" : "flex-start" };
      const bubbleStyle = { ...styles.bubble, ...(mine ? styles.mine : styles.theirs) };

      return (
        <div key={m.id} style={rowStyle}>
          <div style={bubbleStyle} title={new Date(m.ts).toLocaleString()}>
            <div style={{ fontSize: 12, opacity: 0.85, marginBottom: 6 }}>{mine ? "You" : m.user}</div>
            <div style={{ whiteSpace: "pre-wrap" }}>{m.text}</div>
          </div>
        </div>
      );
    })}
    <div ref={messagesEndRef} />
  </div>

  <div style={styles.footer}>
    <div style={{ marginBottom: 6 }}>
      {otherTyping.length ? <span style={styles.small}>{otherTyping.join(", ")} typing...</span> : <span style={styles.small}>No one is typing</span>}
    </div>

    <div style={styles.inputArea}>
      <textarea
        aria-label="Type your message"
        placeholder="Type a message and press Enter to send"
        style={styles.textarea}
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyDown={handleInputKey}
      />
      <button style={styles.sendBtn} onClick={sendMessage} disabled={!connected && !input.trim()}>
        Send
      </button>
    </div>
  </div>
</div>

); }

/* Optional: minimal Node.js WebSocket server example (use separately on your server)

// server.js const WebSocket = require('ws'); const wss = new WebSocket.Server({ port: 8080 });

function broadcast(data, exclude) { const payload = JSON.stringify(data); wss.clients.forEach((c) => { if (c.readyState === WebSocket.OPEN && c !== exclude) c.send(payload); }); }

wss.on('connection', (socket) => { socket.on('message', (raw) => { try { const data = JSON.parse(raw); switch (data.type) { case 'message': // echo message to everyone (including sender if you want) broadcast({ type: 'message', id: data.id, user: data.user, text: data.text, ts: data.ts }); break; case 'typing': broadcast({ type: 'typing', user: data.user, isTyping: data.isTyping }); break; case 'presence': broadcast({ type: 'presence', user: data.user, action: data.action }); break; default: // handle other events break; } } catch (e) { // ignore parse errors } }); });

Run: node server.js Connect the React component with wsUrl="ws://localhost:8080" (or wss:// for TLS) */

